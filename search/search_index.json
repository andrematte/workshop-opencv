{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#sobre-este-workshop","title":"Sobre este Workshop","text":"<p>Este workshop explorar\u00e1, na pr\u00e1tica, as ferramentas b\u00e1sicas utilizadas em projetos de Vis\u00e3o Computacional. A compreens\u00e3o dessas t\u00e9cnicas \u00e9 crucial para construir uma base s\u00f3lida em manipula\u00e7\u00e3o e processamento de imagens, facilitando a aplica\u00e7\u00e3o mais eficaz de algoritmos de Machine Learning em projetos futuros.</p> <p>Os materiais necess\u00e1rios para o acompanhamento do workshop est\u00e3o dispon\u00edveis no GitHub. </p> <p>Os conte\u00fados da aula pr\u00e1tica foram implementados no formato de Jupyter Notebooks e est\u00e3o armazenados no diret\u00f3rio <code>notebooks</code>. J\u00e1 o Projeto Final ser\u00e1 implementado em um script Python puro, localizado em <code>scripts/projetofinal.py</code>.</p>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>Conhecimentos b\u00e1sicos de programa\u00e7\u00e3o na linguagem Python</li> <li>Computador pessoal com Python 3.x instalado para a execu\u00e7\u00e3o dos exerc\u00edcios</li> <li>Ambiente Python configurado e com as seguintes bibliotecas instaladas:<ul> <li>NumPy</li> <li>OpenCV</li> <li>MatPlotLib</li> <li>Jupyter (Opcional)</li> </ul> </li> </ul> <ul> <li> Instru\u00e7\u00f5es para configura\u00e7\u00e3o do ambiente</li> </ul>"},{"location":"#conteudo-do-workshop","title":"Conte\u00fado do Workshop","text":"<ol> <li>Introdu\u00e7\u00e3o ao OpenCV<ol> <li>Representa\u00e7\u00e3o matricial de imagens digitais</li> <li>Leitura, exibi\u00e7\u00e3o e armazenamento de imagens</li> <li>Trabalhando com arquivos de v\u00eddeo</li> <li>Trabalhando com o feed de uma c\u00e2mera externa</li> </ol> </li> <li>Opera\u00e7\u00f5es b\u00e1sicas<ol> <li>Convers\u00e3o entre espa\u00e7os de cores (Escala de cinza, RGB, HSV)</li> <li>Extra\u00e7\u00e3o de Regi\u00f5es de Interesse (ROI)</li> <li>Desenhando formas geom\u00e9tricas nas imagens</li> <li>Inserindo texto nas imagens</li> <li>Opera\u00e7\u00f5es l\u00f3gicas</li> </ol> </li> <li>Transforma\u00e7\u00f5es geom\u00e9tricas<ol> <li>Redimensionamento</li> <li>Transforma\u00e7\u00e3o de perspectiva</li> </ol> </li> <li>Opera\u00e7\u00f5es de filtragem<ol> <li>Aplica\u00e7\u00e3o de filtros (kernels) na imagem</li> <li>Filtros de suaviza\u00e7\u00e3o</li> <li>Filtros de detec\u00e7\u00e3o de bordas</li> </ol> </li> <li>Opera\u00e7\u00f5es de limiariza\u00e7\u00e3o e detec\u00e7\u00e3o de contornos<ol> <li>Opera\u00e7\u00f5es de limiariza\u00e7\u00e3o</li> <li>Detec\u00e7\u00e3o de contornos</li> </ol> </li> <li>Projeto Final</li> </ol>"},{"location":"#historico","title":"Hist\u00f3rico","text":"<p>Se\u00e7\u00e3o #1</p> <p>Ministrado no dia 10/09/2024, \u00e0s 14:00 no LabCity, localizado no Centro de Computa\u00e7\u00e3o de Alto Desempenho da UFPA, por Carlos Andr\u00e9 Mattos (@andrematte - LabCity - UFPA)</p>"},{"location":"configura%C3%A7%C3%A3o/","title":"Configura\u00e7\u00e3o do Ambiente","text":"<p>Esta se\u00e7\u00e3o cont\u00e9m instru\u00e7\u00f5es para a configura\u00e7\u00e3o do ambiente de desenvolvimento contendo as depend\u00eancias necess\u00e1rias para este workshop.</p> <ul> <li>NumPy</li> <li>OpenCV</li> <li>MatPlotLib</li> <li>Jupyter (Opcional)</li> </ul> <p>O m\u00e9todo recomendado para a configura\u00e7\u00e3o do ambiente utiliza o gerenciador de depend\u00eancias <code>Poetry</code>, por\u00e9m outras ferramentas, como <code>virtualenv</code> ou <code>conda</code> tamb\u00e9m podem ser utilizadas.</p>"},{"location":"configura%C3%A7%C3%A3o/#clonando-o-repositorio","title":"Clonando o reposit\u00f3rio","text":"<pre><code>git clone https://github.com/andrematte/workshop-opencv\ncd workshop-opencv\n</code></pre> <p>O uso do Poetry para cria\u00e7\u00e3o do ambiente virtual isolado e instala\u00e7\u00e3o das depend\u00eancias \u00e9 recomendado, por\u00e9m \u00e9 poss\u00edvel instalar tudo com <code>pip install opencv-python matplotlib</code> ou <code>conda install opencv-python matplotlib</code>.</p>"},{"location":"configura%C3%A7%C3%A3o/#configuracao-utilizando-poetry","title":"Configura\u00e7\u00e3o utilizando Poetry","text":"<p>O comando <code>poetry install</code> ir\u00e1 criar um ambiente virtual contendo as depend\u00eancias do projeto, listadas em <code>pyproject.toml</code>.</p> <pre><code>poetry install\n</code></pre>"},{"location":"configura%C3%A7%C3%A3o/#opcional-executar-jupyter-lab","title":"(Opcional) Executar Jupyter Lab","text":"<p>Os conte\u00fados da aula pr\u00e1tica foram implementados no formato de Jupyter Notebooks. Qualquer IDE com suporte a Notebooks pode ser utilizada. Por simplicidade, recomenda-se o Jupyter Lab.</p> <pre><code>poetry shell\npoetry jupyter lab\n</code></pre> <ul> <li>  Com o ambiente devidamente configurado, podemos partir para a primeira se\u00e7\u00e3o: Introdu\u00e7\u00e3o ao OpenCV.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/","title":"1 Introdu\u00e7\u00e3o ao OpenCV","text":"<ul> <li> Para acompanhar esta se\u00e7\u00e3o, abra o arquivo <code>notebooks/1-introducao.ipynb</code>.</li> </ul> <p>O Open Source Computer Vision Library (OpenCV) \u00e9 uma biblioteca de c\u00f3digo aberto que implementa fun\u00e7\u00f5es de processamento de imagem, muito utilizadas em projetos de Vis\u00e3o Computacional.</p> <p></p> <ul> <li>Originalmente desenvolvido pela Intel em 1999</li> <li>Escrito primariamente na linguagem C++, por\u00e9m tamb\u00e9m oferece bindings para Python, Java e Matlab/Octave</li> </ul> <p>A documenta\u00e7\u00e3o do OpenCV est\u00e1 dispon\u00edvel neste link.</p> <p>Nesta primeira se\u00e7\u00e3o do workshop iremos aprender as fun\u00e7\u00f5es b\u00e1sicas de carregamento de imagens com OpenCV:</p> <ol> <li>Representa\u00e7\u00e3o matricial de imagens digitais</li> <li>Leitura, exibi\u00e7\u00e3o e armazenamento de imagens</li> <li>Trabalhando com arquivos de v\u00eddeo</li> <li>Trabalhando com o feed de uma c\u00e2mera externa</li> </ol>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#representacao-matricial-de-imagens-digitais","title":"Representa\u00e7\u00e3o Matricial de Imagens Digitais","text":"<p>A representa\u00e7\u00e3o de imagens digitais no OpenCV e NumPy \u00e9 feita por meio de arrays multidimensionais, ou tensores, implementados pela biblioteca NumPy. Cada imagem \u00e9 composta por uma matriz de n\u00fameros, onde cada valor corresponde \u00e0 intensidade de um pixel.</p> <ul> <li>A intensidade do pixel varia, por padr\u00e3o, entre 0 e 255.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#estrutura-da-imagem","title":"Estrutura da Imagem","text":"<p>Em OpenCV e NumPy, as imagens s\u00e3o representadas por um array NumPy de 2 ou 3 dimens\u00f5es:</p> <ul> <li> <p>Imagem em Escala de Cinza: \u00c9 representada por uma matriz 2D, onde cada elemento cont\u00e9m um valor de intensidade que vai de 0 (preto) a 255 (branco).</p> </li> <li> <p>Imagem Colorida (RGB): \u00c9 representada por uma matriz 3D com 3 canais (para as cores vermelho, verde e azul).</p> </li> </ul> <p>Em OpenCV, a ordem dos canais padr\u00e3o \u00e9 BGR (ao contr\u00e1rio do usual RGB). Aqui, cada pixel \u00e9 um vetor de 3 valores representando as intensidades dos canais B (azul), G (verde) e R (vermelho).</p>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#importando-as-bibliotecas-necessarias","title":"Importando as Bibliotecas Necess\u00e1rias","text":"<p>Vamos iniciar importando as bibliotecas necess\u00e1rias para esta se\u00e7\u00e3o: <code>numpy</code>, <code>cv2</code> e <code>matplotlib.pyplot</code>.</p> <pre><code># Importe as bibliotecas aqui\nimport cv2  \nimport numpy as np \nimport matplotlib.pyplot as plt \n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#leitura-exibicao-e-armazenamento-de-imagens","title":"Leitura, Exibi\u00e7\u00e3o e Armazenamento de Imagens","text":"<p>Vamos carregar a imagem de exemplo <code>/media/gatogordo.jpg</code>.</p> <p>A fun\u00e7\u00e3o cv2.imread() permite a importa\u00e7\u00e3o de um arquivo de imagem, retornando um tensor NumPy. As flags opcionais podem ser utilizadas. As principais flags s\u00e3o:</p> <ul> <li>0: leitura em escala de cinza</li> <li>1: leitura em BGR</li> <li>-1: leitura no formato original</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#escala-de-cinza","title":"Escala de Cinza","text":"<pre><code># Leia a imagem em escala de cinza e armazene-a em uma vari\u00e1vel\nimagem_cinza = cv2.imread(\"media/gatogordo.jpg\", 0)\n</code></pre> <p>Utilize comandos do NumPy para verificar o conte\u00fado do tensor, o formato do tensor <code>imagem.shape</code> e os valores m\u00ednimos e m\u00e1ximos das intensidades dos pixels <code>imagem.min()</code> e <code>imagem.max()</code>. </p> <p>Podemos tamb\u00e9m exibir a imagem para verificar seu conte\u00fado. O OpenCV conta com a fun\u00e7\u00e3o <code>cv2.imshow()</code>, que abre a imagem em uma janela, por\u00e9m esta fun\u00e7\u00e3o n\u00e3o funciona em Notebooks. Para visualizar a imagem Notebooks, vamos utilizar a fun\u00e7\u00e3o <code>plt.imshow()</code> do Matplotlib.</p> <pre><code># Plote a imagem com o mapa de cores \"gray\".\nplt.imshow(imagem_cinza, cmap=\"gray\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#imagem-colorida","title":"Imagem Colorida","text":"<p>Vamos repetir o processo para a imagem colorida (BGR).</p> <pre><code># Carregue a imagem colorida (flag 1)\nimagem_colorida = cv2.imread(\"media/gatogordo.jpg\", 1)\n\n# Plote a imagem com Matplotlib\nplt.imshow(imagem_colorida)\n</code></pre> <p>No OpenCV, a ordem das cores \u00e9 BGR (azul, verde, vermelho), enquanto no Matplotlib a ordem \u00e9 RGB (vermelho, verde, azul). Portanto, ao exibir imagens carregadas com OpenCV usando Matplotlib, \u00e9 comum precisar converter a ordem das cores de BGR para RGB.</p> <p>Podemos converter o espa\u00e7o de cores de BGR para RGB simplesmente reordenando os canais da imagem.</p> <pre><code># Extraia cada banda e armazene-as em vari\u00e1veis\nBLUE = imagem_colorida[:,:,0]\nGREEN = imagem_colorida[:,:,1]\nRED = imagem_colorida[:,:,2]\n</code></pre> <p>Cada pixel das tr\u00eas bandas extra\u00eddas representa a intensidade de cada cor (azul, verde, vermelho) na imagem.</p> <pre><code># Plotar cada banda separadamente com Matplotlib\nplt.figure(figsize=(15, 10))\nplt.subplot(1, 3, 1)\nplt.imshow(RED, cmap=\"Reds\")\nplt.subplot(1, 3, 2)\nplt.imshow(GREEN, cmap=\"Greens\")\nplt.subplot(1, 3, 3)\nplt.imshow(GREEN, cmap=\"Blues\")\n</code></pre> <p>Vamos reordenar as bandas para criar uma imagem RGB.</p> <p>A fun\u00e7\u00e3o np.stack() do NumPy permite empilhar matrizes em qualquer dimens\u00e3o, vamos empilhar as bandas na dimens\u00e3o 2.</p> <pre><code># Montar uma imagem RGB a partir dos canais separados\nimagem_rgb = np.stack([RED, GREEN, BLUE], axis=2)\nplt.imshow(imagem_rgb)\n</code></pre> <p>Agora a imagem \u00e9 mostrada corretamente pelo MatPlotLib!</p> <p>Vamos salvar a imagem em um arquivo com a fun\u00e7\u00e3o <code>cv2.imwrite()</code>.</p> <pre><code># Salve a imagem no disco\ncv2.imwrite(\"media/gatogordo_corrigido.jpg\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#trabalhando-com-arquivos-de-video","title":"Trabalhando com Arquivos de V\u00eddeo","text":"<p>Um arquivo de v\u00eddeo consiste em uma sequ\u00eancia de imagens. A fun\u00e7\u00e3o <code>cv2.VideoCapture</code> \u00e9 capaz de ler e iterar sobre um frame de cada vez. Portanto, todas as funcionalidades utilizadas a imagens podem ser aplicadas aos frames de v\u00eddeo.</p> <p>Vamos criar um objeto de captura de v\u00eddeo:</p> <pre><code># Crie um objeto de captura de v\u00eddeo\ncapture = cv2.VideoCapture(\"media/gatoburro.mp4\")\n</code></pre> <p>A fun\u00e7\u00e3o <code>capture.get()</code> pode ser utilizada com um conjunto de flags para capturar informa\u00e7\u00f5es sobre o arquivo de v\u00eddeo.</p> <ul> <li><code>capture.get(cv2.CAP_PROP_FPS)</code>: retorna a quantidade de frames por segundo (FPS)</li> <li><code>capture.get(cv2.CAP_PROP_FRAME_COUNT)</code>: retorna o n\u00famero total de frames do v\u00eddeo</li> <li><code>capture.get(cv2.CAP_PROP_FRAME_WIDTH)</code>: retorna a largura do v\u00eddeo</li> <li><code>capture.get(cv2.CAP_PROP_FRAME_HEIGHT)</code>: retorna a altura do v\u00eddeo</li> </ul> <p>A fun\u00e7\u00e3o <code>capture.read()</code> itera sobre os frames do v\u00eddeo, retornando o pr\u00f3ximo frame. Vamos ler os frames do v\u00eddeo e plot\u00e1-los com Matplotlib:</p> <pre><code># Leia o pr\u00f3ximo frame do v\u00eddeo\nret, frame = capture.read()\n\n# Converta para RGB\nrgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n# Exiba com matplotlib\nplt.imshow(rgb_frame)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/1-Introdu%C3%A7%C3%A3o-ao-OpenCV/#trabalhando-com-o-feed-de-uma-camera-externa","title":"Trabalhando com o Feed de uma C\u00e2mera Externa","text":"<p>Muitas vezes precisamos trabalhar com transmiss\u00f5es de v\u00eddeo vindas de dispositivos externos, como webcams ou c\u00e2meras IP.</p> <p>No OpenCV, a fun\u00e7\u00e3o <code>cv2.VideoCapture</code> tamb\u00e9m \u00e9 capaz de receber o feed de v\u00eddeo de webcams, por exemplo. Basta trocar o caminho do arquivo de v\u00eddeo pelo id da webcam.</p> <pre><code># Leia o feed de webcam (a webcam padr\u00e3o tem id=0)\ncv2.VideoCapture(0)\n</code></pre> <ul> <li>  Continua na pr\u00f3xima se\u00e7\u00e3o: Opera\u00e7\u00f5es b\u00e1sicas.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/","title":"2 Opera\u00e7\u00f5es B\u00e1sicas","text":"<ul> <li> Para acompanhar esta se\u00e7\u00e3o, abra o arquivo <code>notebooks/2-operacoesbasicas.ipynb</code>.</li> </ul> <p>Nesta se\u00e7\u00e3o iremos aprender as principais opera\u00e7\u00f5es b\u00e1sicas utilizadas em pipelines de processamento de imagens.</p> <ol> <li>Convers\u00e3o de espa\u00e7os de cor (Escala de Cinza, RGB, HSV)</li> <li>Extra\u00e7\u00e3o de regi\u00f5es de interesse (ROI)</li> <li>Desenho de formas geom\u00e9tricas e textos na imagem</li> <li>Opera\u00e7\u00f5es l\u00f3gicas entre imagens</li> </ol>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#importando-as-bibliotecas-necessarias","title":"Importando as bibliotecas necess\u00e1rias","text":"<p>Vamos iniciar importando as bibliotecas necess\u00e1rias para esta se\u00e7\u00e3o: <code>numpy</code>, <code>cv2</code> e <code>matplotlib.pyplot</code>.</p> <pre><code># Importe as bibliotecas aqui\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#conversao-de-espacos-de-cores","title":"Convers\u00e3o de Espa\u00e7os de Cores","text":"<p>Os espa\u00e7os de cores s\u00e3o maneiras de representar cores, cada um com diferentes finalidades. Os principais espa\u00e7os de cores usados no processamento de imagens incluem</p> <ul> <li>Escala de Cinza</li> <li>RGB (Red, Green, Blue)</li> <li>HSV (Hue/Matiz, Satura\u00e7\u00e3o, Brilho)</li> </ul> <p>No OpenCV, a fun\u00e7\u00e3o <code>cv2.cvtColor()</code> \u00e9 utilizada para convers\u00e3o entre os espa\u00e7os.</p> <p>Vamos carregar a imagem <code>media/gatogordo.jpg</code> no formato BGR.</p> <pre><code># Carregue a imagem colorida (flag 1)\nimagem_bgr = cv2.imread(\"media/gatogordo.jpg\", 1)\n\n# Plote a imagem com Matplotlib\nplt.imshow(imagem_bgr)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#conversao-para-rgb","title":"Convers\u00e3o para RGB","text":"<p>Na se\u00e7\u00e3o anterior realizamos a convers\u00e3o de BGR para RGB manualmente, mas tamb\u00e9m \u00e9 poss\u00edvel utilizar a fun\u00e7\u00e3o <code>cv2.cvtColor()</code></p> <p>Flag: <code>cv2.COLOR_BGR2RGB</code></p> <p>RGB \u00e9 o espa\u00e7o de cores mais comum, onde cada cor \u00e9 definida por uma combina\u00e7\u00e3o de tr\u00eas valores, que representam a intensidade de cada cor prim\u00e1ria: vermelho, verde e azul. A maioria das imagens digitais \u00e9 representada em RGB.</p> <pre><code># Converta a imagem de BGR para RGB\nimagem_rgb = cv2.cvtColor(\"media/gatogordo.jpg\", cv2.COLOR_BGR2RGB)\n\n# Plote a imagem com Matplotlib\nplt.imshow(imagem_rgb)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#conversao-para-grayscale-escala-de-cinza","title":"Convers\u00e3o para Grayscale (Escala de Cinza)","text":"<p>\u00c9 um espa\u00e7o de cores com apenas uma dimens\u00e3o, representando varia\u00e7\u00f5es de intensidade de luz, indo do preto (valor 0) ao branco (valor 255). N\u00e3o cont\u00e9m informa\u00e7\u00f5es de cor, apenas a intensidade luminosa.</p> <p>Flag: <code>cv2.COLOR_BGR2GRAY</code></p> <pre><code># Converta a imagem de BGR para GRAY\nimagem_gray = cv2.cvtColor(imagem_bgr, cv2.COLOR_BGR2GRAY)\n\n# Plote a imagem com Matplotlib\nplt.imshow(imagem_gray, cmap=\"grey\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#hsv-hue-saturation-value","title":"HSV (Hue, Saturation, Value)","text":"<p>Esse espa\u00e7o de cores representa as cores de uma forma mais intuitiva:</p> <ul> <li>Hue (Matiz): Representa a cor (0 a 360\u00b0 no c\u00edrculo crom\u00e1tico).</li> <li>Saturation (Satura\u00e7\u00e3o): Define a \u201cpureza\u201d ou intensidade da cor (0 a 100%).</li> <li>Value (Valor de Brilho): Representa o brilho da cor (0 a 100%).</li> </ul> <p></p> <p>Flag: <code>cv2.COLOR_BGR2HSV</code></p> <pre><code># Converta a imagem de BGR para HSV\nimagem_hsv = cv2.cvtColor(imagem_bgr, cv2.COLOR_BGR2HSV)\n</code></pre> <ul> <li> Tente exibir cada componente (canal) da imagem em HSV separadamente utilizando o mapa de cores <code>hsv</code> do Matplotlib.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#extracao-de-regioes-de-interesse-roi","title":"Extra\u00e7\u00e3o de Regi\u00f5es de Interesse (ROI)","text":"<p>Em muitos projetos ser\u00e1 necess\u00e1rio tratar partes espec\u00edficas de uma imagem, denominadas Regi\u00f5es de Interesse (ROI). Para extrair uma ROI \u00e9 poss\u00edvel usar a ferramenta de slicing do NumPy.</p> <p>Em uma imagem colorida (RGB), geralmente representada por um array com a forma (altura, largura, canais), o slicing permite selecionar uma parte da imagem, definindo intervalos para as dimens\u00f5es de altura e largura.</p> <p>A opera\u00e7\u00e3o de slicing \u00e9 feita com a seguinte sintaxe: <code>imagem[a1:b1, a2:b2, c1:c2]</code>. O operador <code>:</code> permite a sele\u00e7\u00e3o de todos os elementos entre <code>a</code> e <code>b</code>.</p> <p>Extraia uma ROI contendo a imagem inteira:</p> <pre><code># Extraia uma ROI contendo a imagem inteira\nroi = imagem_rgb[:, :, :]\n\n# Exiba a ROI com Matplotlib\nplt.imshow(roi)\n</code></pre> <p>Extraia uma ROI contendo a metade esquerda da imagem:</p> <pre><code># Extraia uma ROI contendo a metade esquerda da imagem\nroi = imagem_rgb[:, :600, :]\n\n# Exiba a ROI com Matplotlib\nplt.imshow(roi)\n</code></pre> <p>Agora vamos extrair apenas a face do Gato:</p> <pre><code># Extraia uma ROI explicitamente contendo a face do gato\nroi = imagem_rgb[150:550, 500:950, :]\n\n# Exiba a ROI com Matplotlib\nplt.imshow(roi)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#desenhando-formas-geometricas-na-imagem","title":"Desenhando Formas Geom\u00e9tricas na Imagem","text":"<p>Nesta se\u00e7\u00e3o vamos explorar as fun\u00e7\u00f5es do OpenCV que permitem a inser\u00e7\u00e3o de formas geom\u00e9tricas na imagem.</p> <p>Essas fun\u00e7\u00f5es de desenho s\u00e3o amplamente utilizadas em aplica\u00e7\u00f5es pr\u00e1ticas:</p> <ul> <li>Visualiza\u00e7\u00e3o: Desenhar contornos, destacar objetos e adicionar feedback visual em algoritmos de detec\u00e7\u00e3o (como detec\u00e7\u00e3o de rostos, contagem de objetos, ou rastreamento de movimento).</li> <li>Anota\u00e7\u00e3o e Rotulagem: Facilitar a anota\u00e7\u00e3o manual de dados para treinamento de modelos de machine learning.</li> <li>Depura\u00e7\u00e3o: Durante o desenvolvimento, ajudam a verificar se os algoritmos de processamento de imagem est\u00e3o funcionando corretamente, mostrando \u00e1reas de interesse ou resultados diretamente sobre a imagem.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#desenhando-linhas","title":"Desenhando Linhas","text":"<p>Vamos come\u00e7ar desenhando linhas na imagem com a fun\u00e7\u00e3o <code>cv2.line()</code>:</p> <pre><code># Fa\u00e7a uma c\u00f3pia da imagem_rgb\nimagem_com_linhas = imagem_rgb.copy()\n\n# Desenhe um X na imagem (2 linhas)\ncv2.line(img = imagem_com_linhas,\n         pt1 = (0, 0),\n         pt2 = (1250, 1250), \n         color = (255, 0, 0),\n         thickness =  10\n        )\n\ncv2.line(img = imagem_com_linhas,\n         pt1 = (0, 1250),\n         pt2 = (1250, 0), \n         color = (255, 0, 0),\n         thickness =  10\n        )\n\n# Plote a imagem\nplt.imshow(imagem_com_linhas)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#desenhando-formas-geometricas","title":"Desenhando Formas Geom\u00e9tricas","text":"<p>A fun\u00e7\u00e3o <code>cv2.rectangle()</code> desenha um ret\u00e2ngulo na imagem de entrada.</p> <p></p> <p>Desenhe uma caixa delimitadora ao redor do gato</p> <pre><code># Fa\u00e7a uma c\u00f3pia da imagem_rgb\nimagem_com_retangulos = imagem_rgb.copy()\n\n# Desenhe uma Bounding Box ao redor do gato\ncv2.rectangle(img = imagem_com_retangulos, \n              pt1 = (50, 170), \n              pt2 = (1120, 1150), \n              color = (0, 255, 0), \n              thickness = 10)\n\n# Plote a imagem\nplt.imshow(imagem_com_retangulos)\n</code></pre> <p>De forma similar, a fun\u00e7\u00e3o <code>cv2.circle</code> desenha um c\u00edrculo na imagem:</p> <pre><code># Fa\u00e7a uma c\u00f3pia da imagem_rgb\nimagem_com_circulos = imagem_rgb.copy()\n\n# Desenhe um c\u00edrculo para cobrir o rosto do gato\ncv2.circle(imagem_com_circulos, \n           center = (800, 400), \n           radius = 250, \n           color = (0, 255, 255), \n           thickness = 10)\n\n# Plote a imagem\nplt.imshow(imagem_com_circulos)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#inserindo-textos-na-imagem","title":"Inserindo Textos na Imagem","text":"<p>Tamb\u00e9m \u00e9 poss\u00edvel inserir textos na imagem com a fun\u00e7\u00e3o <code>cv2.putText()</code>.</p> <pre><code># Crie uma c\u00f3pia da imagem RGB\nimagem_com_texto = imagem_rgb.copy()\n\n# Defina o texto que quer inserir\ntexto = \"Gato Gordo!\"\n\n# Insira o texto na imagem\ncv2.putText(\n    img=imagem_com_texto,\n    text=texto,\n    org=(50, 150),\n    fontFace=cv2.FONT_HERSHEY_SIMPLEX,\n    fontScale=3,\n    color=(255, 255, 255),\n    thickness=20,\n)\n\n# Use a fun\u00e7\u00e3o cv2.arrowedLine() para desenhar \n# uma seta apontando do texto para o gato\ncv2.arrowedLine(\n    img=imagem_com_texto,\n    pt1=(300, 200),\n    pt2=(550, 400),\n    color=(255, 255, 255),\n    thickness=10,\n)\n\n# Exiba\nplt.imshow(imagem_com_texto)\n</code></pre> <ul> <li> Uma aplica\u00e7\u00e3o \u00fatil \u00e9 a inser\u00e7\u00e3o de Timestamps na imagem.</li> </ul> <pre><code># Importe a biblioteca datetime\nimport datetime\n\n# Fa\u00e7a uma c\u00f3pia da imagem\nimagem_com_timestamp = imagem_rgb.copy()\n\n# Armazene a data e hora atual em uma vari\u00e1vel\ntexto = datetime.datetime.now().strftime(\"%d/%m/%Y %H:%M:%S\")\n\n# Insera o texto na imagem\ncv2.putText(\n    img=imagem_com_timestamp,\n    text=texto,\n    org=(50, 1200),\n    fontFace=cv2.FONT_HERSHEY_SIMPLEX,\n    fontScale=2,\n    color=(255, 255, 255),\n    thickness=10,\n)\n\n# Plote a imagem\nplt.imshow(imagem_com_timestamp)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#operacoes-logicas","title":"Opera\u00e7\u00f5es L\u00f3gicas","text":"<p>As opera\u00e7\u00f5es l\u00f3gicas bitwise no OpenCV permitem manipular os pixels de uma imagem de maneira bin\u00e1ria, usando opera\u00e7\u00f5es como AND, OR, XOR, e NOT. Essas opera\u00e7\u00f5es s\u00e3o fundamentais para combinar, mascarar ou destacar regi\u00f5es espec\u00edficas de imagens. Elas s\u00e3o comumente usadas em tarefas de segmenta\u00e7\u00e3o, extra\u00e7\u00e3o de regi\u00f5es de interesse e combina\u00e7\u00e3o de imagens.</p> <p></p> <p>Para demonstrar as opera\u00e7\u00f5es l\u00f3gicas, vamos criar duas m\u00e1scaras bin\u00e1rias, uma contendo um c\u00edrculo e outra um quadrado</p> <pre><code># Criar duas imagens vazias usando NumPy\n# Dimens\u00f5es da imagem (400x400)\nquadrado = np.zeros((400, 400), dtype=np.uint8)\ncirculo = np.zeros((400, 400), dtype=np.uint8)\n\n# Desenhar um ret\u00e2ngulo branco na primeira imagem\ncv2.rectangle(quadrado, (40, 40), (360, 360), 255, -1)\n\n# Desenhar um c\u00edrculo branco na segunda imagem\ncv2.circle(circulo, (200, 200), 200, 255, -1)\n\n# Mostrar as imagens em subplots\nplt.subplot(121)\nplt.imshow(quadrado)\nplt.subplot(122)\nplt.imshow(circulo)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#operacao-not","title":"Opera\u00e7\u00e3o NOT","text":"<p><code>cv2.bitwise_not()</code></p> <ul> <li>Realiza uma opera\u00e7\u00e3o NOT bit a bit, invertendo todos os bits de uma imagem. Os pixels pretos (0) tornam-se brancos (255), e os brancos tornam-se pretos.</li> <li>Aplica\u00e7\u00e3o: Usada para inverter imagens ou criar m\u00e1scaras complementares.</li> </ul> <pre><code># Inverta a imagem do c\u00edrculo\nresult = cv2.bitwise_not(circulo)\n\n# Exiba a imagem\nplt.imshow(result)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#operacao-and","title":"Opera\u00e7\u00e3o AND","text":"<p><code>cv2.bitwise_and()</code></p> <ul> <li>Realiza uma opera\u00e7\u00e3o AND bit a bit entre duas imagens. O pixel resultante ser\u00e1 branco (255) apenas se os dois pixels correspondentes forem brancos nas duas imagens.</li> <li>Aplica\u00e7\u00e3o: Usada para segmentar ou extrair uma regi\u00e3o espec\u00edfica de uma imagem usando uma m\u00e1scara.</li> </ul> <pre><code># Aplique a opera\u00e7\u00e3o AND nas imagens do quadrado e c\u00edrculo\nresult = cv2.bitwise_and(quadrado, circulo)\n\n# Exiba a imagem\nplt.imshow(result)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#operacao-or","title":"Opera\u00e7\u00e3o OR","text":"<p><code>cv2.bitwise_or</code></p> <ul> <li>Realiza uma opera\u00e7\u00e3o OR bit a bit entre duas imagens. O pixel resultante ser\u00e1 branco se pelo menos um dos pixels correspondentes for branco em uma das imagens.</li> <li>Aplica\u00e7\u00e3o: Usada para combinar duas imagens ou sobrepor regi\u00f5es.</li> </ul> <pre><code># Aplique a opera\u00e7\u00e3o OR\nresult = cv2.bitwise_or(quadrado, circulo)\n\n# Exiba a imagem\nplt.imshow(result)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/2-Opera%C3%A7%C3%B5es-B%C3%A1sicas/#operacao-bitwise-xor","title":"Opera\u00e7\u00e3o Bitwise XOR","text":"<ul> <li>Realiza uma opera\u00e7\u00e3o XOR bit a bit entre duas imagens. O pixel resultante ser\u00e1 branco se apenas um dos pixels correspondentes for branco, mas n\u00e3o ambos.</li> <li>Aplica\u00e7\u00e3o: Usada para destacar as diferen\u00e7as entre duas imagens.</li> </ul> <pre><code># Aplique a opera\u00e7\u00e3o XOR\nresult = cv2.bitwise_xor(quadrado, circulo)\n\n# Exiba a imagem\nplt.imshow(result)\n</code></pre> <ul> <li> O que acontecer\u00e1 se aplicarmos as opera\u00e7\u00f5es na nossa imagem de exemplo?</li> </ul> <pre><code># Fa\u00e7a uma c\u00f3pia da imagem de exemplo em escala de cinza\nexemplo = imagem_gray.copy()\n\n# Exiba a imagem\nplt.imshow(exemplo)\n</code></pre> <p>Agora fa\u00e7a uma m\u00e1scara bin\u00e1ria contendo um c\u00edrculo</p> <pre><code># Crie uma matriz vazia do mesmo tamanho da imagem\ncirculo = np.zeros((1250, 1250), dtype=np.uint8)\n\n# Desenhe um circulo na imagem\ncv2.circle(circulo, (800, 400), 250, 255, -1)\n\n# Exiba o circulo\nplt.imshow(circulo)\n</code></pre> <p>Fa\u00e7a a opera\u00e7\u00e3o correta para aplicar a m\u00e1scara de segmenta\u00e7\u00e3o na imagem do gato\"</p> <pre><code># Aplique a opera\u00e7\u00e3o l\u00f3gica correta\nresultado = cv2.bitwise_and(exemplo, circulo)\n\n# Exiba a imagem\nplt.imshow(resultado)\n</code></pre> <ul> <li>  Continua na pr\u00f3xima se\u00e7\u00e3o: Transforma\u00e7\u00f5es Geom\u00e9tricas.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/3-Transforma%C3%A7%C3%B5es-Geom%C3%A9tricas/","title":"3 Transforma\u00e7\u00f5es Geom\u00e9tricas","text":"<ul> <li> Para acompanhar esta se\u00e7\u00e3o, abra o arquivo <code>notebooks/3-transformacoes.ipynb</code>.</li> </ul> <p>As transforma\u00e7\u00f5es geom\u00e9tricas em OpenCV s\u00e3o usadas para alterar a posi\u00e7\u00e3o, o tamanho, a orienta\u00e7\u00e3o ou a forma de uma imagem. Isso \u00e9 fundamental em tarefas de vis\u00e3o computacional, como o ajuste de perspectiva, rota\u00e7\u00e3o de imagens e alinhamento de objetos.</p> <p>Nesta se\u00e7\u00e3o vamos abordar os seguintes itens:</p> <ol> <li>Redimensionamento de imagens</li> <li>Extra: Opera\u00e7\u00f5es matem\u00e1ticas entre imagens</li> <li>Transforma\u00e7\u00e3o de Perspectiva (Warp Perspective)</li> </ol>"},{"location":"Conte%C3%BAdo-do-Workshop/3-Transforma%C3%A7%C3%B5es-Geom%C3%A9tricas/#importando-as-bibliotecas-necessarias","title":"Importando as bibliotecas necess\u00e1rias","text":"<p>Vamos iniciar importando as bibliotecas necess\u00e1rias para esta se\u00e7\u00e3o: <code>numpy</code>, <code>cv2</code> e <code>matplotlib.pyplot</code>.</p> <pre><code># Importe as bibliotecas necessarias:\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/3-Transforma%C3%A7%C3%B5es-Geom%C3%A9tricas/#redimensionamento-de-imagens","title":"Redimensionamento de Imagens","text":"<p>O redimensionamento altera o tamanho da imagem, aumentando ou reduzindo sua largura e altura.</p> <pre><code># Carregue a imagem `media/gatogordo.jpg` no formato BGR\nimagem = cv2.imread(\"media/gatogordo.jpg\", 1)\n\n# Converta a imagem para RGB\nimagem_rgb = cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB)\n\n# Exiba a imagem\nplt.imshow(imagem_rgb)\n</code></pre> <p>A fun\u00e7\u00e3o <code>cv2.resize()</code> permite a opera\u00e7\u00e3o de redimensionamento de imagens.</p> <pre><code># Redimensione a imagem para o tamanho desejado\nimagem_redim = cv2.resize(imagem, (64, 64))\n\n# Exiba a imagem redimensionada\nplt.imshow(imagem_redim)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/3-Transforma%C3%A7%C3%B5es-Geom%C3%A9tricas/#extra-operacoes-matematicas-entre-imagens","title":"Extra: Opera\u00e7\u00f5es Matem\u00e1ticas entre Imagens","text":"<p>Opera\u00e7\u00f5es entre imagens diferentes pode ser \u00fatil em v\u00e1rios cen\u00e1rios. Podemos somar, subtrair e multiplicar imagens, afinal elas s\u00e3o matrizes. Uma das utilidades da soma entre imagens \u00e9 para a inclus\u00e3o de marca d'\u00e1gua.</p> <p>Vamos inserir o logo da UFPA como marca d'\u00e1gua na imagem do gato gordo!</p> <pre><code># Carregue o logo da UFPA e converter para RGB\nlogo = cv2.cvtColor(cv2.imread(\"media/logo.png\"), cv2.COLOR_BGR2RGB)\n\n# Exiba o logo da UFPA\nplt.imshow(logo)\n</code></pre> <p>Precisamos redimensionar o logo para que ele tenha o mesmo tamanho da imagem</p> <pre><code># Redimensione o logo para 1250x1250\nlogo_redim = cv2.resize(logo, (1250, 1250))\n\n# Exiba o logo redimensionado\nplt.imshow(logo_redim)\n</code></pre> <p>Agora que as duas imagens tem dimens\u00f5es compat\u00edveis, podemos som\u00e1-las com a fun\u00e7\u00e3o <code>cv2.add()</code>.</p> <pre><code># Some as duas imagens\nsoma = cv2.add(imagem, logo_redim)\n\n# Exiba a imagem resultante\nplt.imshow(soma)\n</code></pre> <p>Simplesmente somar as duas imagens n\u00e3o \u00e9 o ideal para a inser\u00e7\u00e3o de marcas d'\u00e1gua. Devemos realizar uma soma ponderada com a fun\u00e7\u00e3o <code>cv2.addWeighted()</code>.</p> <pre><code># Use a soma ponderada para combinar as imagens\nsoma_ponderada = cv2.addWeighted(\n    src1=imagem, alpha=1, src2=logo_redim, beta=0.10, gamma=0\n)\n\n# Exibir a imagem\nplt.imshow(soma_ponderada)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/3-Transforma%C3%A7%C3%B5es-Geom%C3%A9tricas/#transformacao-de-perspectiva-warp-perspective","title":"Transforma\u00e7\u00e3o de Perspectiva (Warp Perspective)","text":"<p>Muitas vezes o objeto de interesse n\u00e3o est\u00e1 sendo visto diretamente na imagem, dificultando o seu processamento. A transforma\u00e7\u00e3o de perspectiva \u00e9 uma boa solu\u00e7\u00e3o para simular o ponto de vista ideal do objeto.</p> <p></p> <p>Para ilustrar esta transforma\u00e7\u00e3o, utilizaremos o a imagem <code>media/dragon.png</code>.</p> <pre><code># Carregar a imagem `media/dragon.png` e converter para RGB\ndragon = cv2.cvtColor(cv2.imread(\"media/dragon.jpg\"), cv2.COLOR_BGR2RGB)\n\n# Exibir a imagem\nplt.imshow(dragon)\n</code></pre> <p>Aqui queremos ver a carta com uma vista de cima. Para isso, temos que encontrar os quatro pontos da imagem original.</p> <pre><code># Fa\u00e7a uma c\u00f3pia da imagem para desenhar os pontos\npontos = dragon.copy()\n\n# Encontre os quatro pontos na imagem\n# Ponto 1\nponto1 = (770, 535)\ncv2.circle(pontos, ponto1, 20, (255,0,0), -1)\n\n# Ponto 2\nponto2 = (945, 705)\ncv2.circle(pontos, ponto2, 20, (255, 0, 0), -1)\n\n# Ponto 3\nponto3 = (160, 630)\ncv2.circle(pontos, ponto3, 20, (255, 0, 0), -1)\n\n# Ponto 4\nponto4 = (185, 870)\ncv2.circle(pontos, ponto4, 20, (255, 0, 0), -1)\n\n# Transforme os pontos em um array do numpy\npontos_origem = np.float32([ponto1, ponto2, ponto3, ponto4])\n\n# Conectando os pontos, para visualiza\u00e7\u00e3o\ncv2.line(pontos, ponto1, ponto2, (0, 255, 0), 5)\ncv2.line(pontos, ponto2, ponto4, (0, 255, 0), 5)\ncv2.line(pontos, ponto4, ponto3, (0, 255, 0), 5)\ncv2.line(pontos, ponto3, ponto1, (0, 255, 0), 5)\n\n# Exiba a imagem com os pontos conectados\nplt.imshow(pontos)\n</code></pre> <p>Agora precisamos definir os pontos nas coordenadas de destino:</p> <pre><code># Defina o tamanho da imagem resultante\nwidth, height = 250, 400 \n\n# Defina os quatro pontos de destino para transformar a perspectiva\npontos_destino = np.float32([[0, 0], [width, 0], [0, height], [width, height]])\n</code></pre> <p>Agora que temos o conjunto de pontos de origem e de destino, podemos calcular a matriz de transforma\u00e7\u00e3o de perspectiva e aplicar a transforma\u00e7\u00e3o.</p> <pre><code># Obtenha a matriz de transforma\u00e7\u00e3o de perspectiva\nmatriz = cv2.getPerspectiveTransform(pontos_origem, pontos_destino)\n\n# Realize a transforma\u00e7\u00e3o de perspectiva\ncarta = cv2.warpPerspective(dragon, matriz, (width, height))\n\n# Exiba a imagem resultante\nplt.imshow(carta)\n</code></pre> <ul> <li>  Continua na pr\u00f3xima se\u00e7\u00e3o: Opera\u00e7\u00f5es de Filtragem.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/4-Opera%C3%A7%C3%B5es-de-Filtragem/","title":"4 Opera\u00e7\u00f5es de Filtragem","text":"<ul> <li> Para acompanhar esta se\u00e7\u00e3o, abra o arquivo <code>notebooks/4-filtros.ipynb</code>.</li> </ul> <p>As opera\u00e7\u00f5es de filtragem s\u00e3o t\u00e9cnicas fundamentais em processamento de imagens, utilizadas para modificar ou real\u00e7ar determinadas caracter\u00edsticas de uma imagem, como suavizar ru\u00eddos, real\u00e7ar detalhes ou detectar bordas. Essas opera\u00e7\u00f5es funcionam aplicando um filtro (ou kernel) sobre a imagem, que consiste em uma pequena matriz de n\u00fameros. Cada valor da imagem \u00e9 ajustado com base nos seus vizinhos, conforme definido pelo filtro.</p> <p>As opera\u00e7\u00f5es de filtragem podem ser vistas como o processo de convolu\u00e7\u00e3o de uma imagem com um kernel. O kernel passa por cada pixel da imagem, calculando o valor do novo pixel com base em seus vizinhos. As diferentes escolhas de kernels resultam em diversos tipos de filtros, como suaviza\u00e7\u00e3o, nitidez, e detec\u00e7\u00e3o de bordas.</p> <p></p>"},{"location":"Conte%C3%BAdo-do-Workshop/4-Opera%C3%A7%C3%B5es-de-Filtragem/#importando-as-bibliotecas-necessarias","title":"Importando as bibliotecas necess\u00e1rias","text":"<p>Vamos iniciar importando as bibliotecas necess\u00e1rias para esta se\u00e7\u00e3o: <code>numpy</code>, <code>cv2</code> e <code>matplotlib.pyplot</code>.</p> <pre><code># Importe as bibliotecas necessarias:\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/4-Opera%C3%A7%C3%B5es-de-Filtragem/#deslizamento-de-filtros-na-imagem","title":"Deslizamento de Filtros na Imagem","text":"<pre><code># Carregue a imagem `media/gengar.png` no formato BGR\nimagem = cv2.imread(\"media/gengar.png\", 1)\n\n# Converta a imagem para RGB\nimagem_rgb = cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB)\n\n# Exiba a imagem\nplt.imshow(imagem)\n</code></pre> <p>Vamos criar filtros (kernels) 3x3 para diversas tarefas.</p> <p>Detec\u00e7\u00e3o de Linhas Horizontais:</p> <pre><code># Defina um kernel para detec\u00e7\u00e3o de linhas horizontais\nkernel_horizontal = np.array([[1, 1, 1], [0, 0, 0], [-1, -2, -1]])\n\n# Realize o deslizamento do kernel na imagem\nhorizontais = cv2.filter2D(imagem_rgb, -1, kernel_horizontal)\n\n# Exiba a imagem resultante\nplt.imshow(horizontais)\n</code></pre> <p>Detec\u00e7\u00e3o de Linhas Verticais:</p> <pre><code># Definir um kernel para detec\u00e7\u00e3o de linhas verticais\nkernel_vertical = np.array([[1, 0, -1], [1, 0, -1], [1, 0, -1]])\n\n# Realizar deslizamento do kernel na imagem\nverticais = cv2.filter2D(imagem_rgb, -1, kernel_vertical)\n\n# Exibir a imagem resultante\nplt.imshow(verticais)\n</code></pre> <p>Combina\u00e7\u00e3o das linhas verticais e horizontais:</p> <pre><code># Some as detec\u00e7\u00f5es horizontais e verticais\nsoma = horizontais + verticais\n\n# Exiba a imagem resultante\nplt.imshow(soma)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/4-Opera%C3%A7%C3%B5es-de-Filtragem/#filtros-de-deteccao-de-bordas","title":"Filtros de Detec\u00e7\u00e3o de Bordas","text":"<p>Filtros de detec\u00e7\u00e3o de bordas s\u00e3o essenciais para identificar contornos de objetos em uma imagem. Eles funcionam real\u00e7ando as \u00e1reas onde h\u00e1 transi\u00e7\u00f5es abruptas de intensidade (bordas).</p> <ul> <li>Filtro Sobel</li> <li>Filtro Canny</li> <li>Filtro Prewitt</li> </ul> <p>Vamos testar o Algoritmo Canny Edge Detection:</p> <pre><code># Aplique o filtro de Canny para detec\u00e7\u00e3o de bordas\nbordas = cv2.Canny(imagem_rgb, 150, 210)\n\n# Exiba a imagem resultante\nplt.imshow(bordas, cmap=\"Spectral\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/4-Opera%C3%A7%C3%B5es-de-Filtragem/#filtros-de-suavizacao-blur","title":"Filtros de Suaviza\u00e7\u00e3o (Blur)","text":"<p>Filtros de suaviza\u00e7\u00e3o s\u00e3o usados para reduzir ru\u00eddos e varia\u00e7\u00f5es bruscas na intensidade dos pixels. Eles s\u00e3o frequentemente usados para melhorar a qualidade visual da imagem, reduzindo o ru\u00eddo ou granula\u00e7\u00e3o.</p> <ul> <li>Filtro de M\u00e9dia</li> <li>Filtro Gaussiano</li> <li>Filtro Bilateral</li> <li>Filtro de Mediana</li> </ul> <pre><code># Defina uma tupla para o tamanho do filtro\ntamanho_do_filtro = (5, 5)\n\n# Aplique o filtro de m\u00e9dia na imagem\nimagem_borrada = cv2.blur(imagem_rgb, tamanho_do_filtro)\n\n# Exiba a imagem resultante\nplt.imshow(imagem_borrada)\n</code></pre> <ul> <li>  Continua na pr\u00f3xima se\u00e7\u00e3o: Opera\u00e7\u00f5es de Limiariza\u00e7\u00e3o e Detec\u00e7\u00e3o de Contornos.</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/","title":"5 Opera\u00e7\u00f5es de Limiariza\u00e7\u00e3o e Detec\u00e7\u00e3o de Contornos","text":"<ul> <li> Para acompanhar esta se\u00e7\u00e3o, abra o arquivo <code>notebooks/5-limiarizacao.ipynb</code>.</li> </ul> <p>Limiariza\u00e7\u00e3o \u00e9 uma t\u00e9cnica fundamental no processamento de imagens utilizada para separar objetos de interesse em uma imagem, com base nos valores de intensidade dos pixels.</p> <p>Na limiariza\u00e7\u00e3o, um valor de limiar (threshold) \u00e9 definido, e cada pixel da imagem \u00e9 comparado com esse valor. Se o valor do pixel for maior ou igual ao limiar, ele \u00e9 alterado para um valor m\u00e1ximo (geralmente 255, branco); caso contr\u00e1rio, \u00e9 alterado para 0 (preto).</p> <p>Vamos testar as fun\u00e7\u00f5es de limiariza\u00e7\u00e3o com o arquivo <code>media/gradient.jpg</code>.</p>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#importando-as-bibliotecas-necessarias","title":"Importando as bibliotecas necess\u00e1rias","text":"<p>Vamos iniciar importando as bibliotecas necess\u00e1rias para esta se\u00e7\u00e3o: <code>numpy</code>, <code>cv2</code> e <code>matplotlib.pyplot</code>.</p> <pre><code># Importe as bibliotecas necessarias:\nimport numpy as np\nimport cv2\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#limiarizacao-simples","title":"Limiariza\u00e7\u00e3o Simples","text":"<p>Vamos testar as t\u00e9cnicas de limiariza\u00e7\u00e3o na imagem <code>media/gradient.jpg</code>.</p> <pre><code># Carregue a imagem 'media/gradient.jpg'\ngradiente = cv2.imread(\"media/gradient.jpg\", 0)\n\n# Exiba a imagem\nplt.imshow(gradiente, cmap=\"gray\")\n</code></pre> <p>Aplique a limiariza\u00e7\u00e3o simples com a fun\u00e7\u00e3o <code>cv2.threshold()</code></p> <pre><code># Selecione o valor do Limiar\nlimiar = 127\n\n# Realize a Limiariza\u00e7\u00e3o\n_, binarizada = cv2.threshold(gradiente, limiar, 255, cv2.THRESH_BINARY)\n\n# Exiba a imagem\nplt.imshow(binarizada, cmap=\"gray\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#limiarizacao-inversa","title":"Limiariza\u00e7\u00e3o Inversa","text":"<pre><code># Selecione o valor do Limiar\nlimiar = 127\n\n# Realize a Limiariza\u00e7\u00e3o Inversa\n_, binarizada = cv2.threshold(gradiente, limiar, 255, cv2.THRESH_BINARY_INV)\n\n# Exiba a imagem\nplt.imshow(binarizada, cmap=\"gray\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#testando-diferentes-limiares","title":"Testando diferentes limiares","text":"<p>Vamos testar diferentes valores de limiar na imagem de exemplo.</p> <pre><code># Carregue o arquivo `media/gatogordo.jpg` em escala de cinza\nimagem = cv2.imread(\"media/gatogordo.jpg\", 0)\n\n# Exibir a imagem\nplt.imshow(imagem, cmap=\"gray\")\n</code></pre> <p>Aplique diferentes valores de limiar:</p> <pre><code># Testar diferentes valores de limiar\nlimiar = 115\n\n# Testar diferentes tipos de limiariza\u00e7\u00e3o\n_, binarizada = cv2.threshold(imagem, limiar, 255, cv2.THRESH_BINARY)\n\n# Exibir a imagem\nplt.imshow(binarizada, cmap=\"gray\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#limiarizacao-automatica-otsu","title":"Limiariza\u00e7\u00e3o Autom\u00e1tica Otsu","text":"<p>Existem m\u00e9todos para detec\u00e7\u00e3o autom\u00e1tica do limiar que melhor separa os grupos de pixels da imagem. Um desses m\u00e9todos \u00e9 o <code>cv2.THRESH_OTSU</code>.</p> <pre><code># Aplique a opera\u00e7\u00e3o de thresholding usando a\n# combina\u00e7\u00e3o de `cv2.THRESH_BINARY` e `cv2.THRESH_OTSU`\notsu_valor, otsu_thresh = cv2.threshold(\n    imagem, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU\n)\n\n# Exiba a imagem\nplt.imshow(otsu_thresh, cmap=\"gray\")\n</code></pre> <p>Ao somar as duas flags, voc\u00ea est\u00e1 dizendo ao OpenCV que quer usar a binariza\u00e7\u00e3o bin\u00e1ria <code>cv2.THRESH_BINARY</code>, com o valor de limiar calculado automaticamente pelo m\u00e9todo de Otsu <code>cv2.THRESH_OTSU</code>.</p>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#limizarizacao-deteccao-de-contornos","title":"Limizariza\u00e7\u00e3o + Detec\u00e7\u00e3o de Contornos","text":"<ul> <li> Mini Projeto: elaborar uma metodologia de vis\u00e3o computacional para realizar a contagem de moedas na imagem <code>media/moedas.jpg</code>.</li> </ul> <p>Passo-a-passo:</p> <ol> <li>Suavizar a imagem para reduzir ru\u00eddos</li> <li>Aplicar limiariza\u00e7\u00e3o para extrair a m\u00e1scara de segmenta\u00e7\u00e3o</li> <li>Detectar os contornos</li> <li>Desenhar caixas delimitadora nos objetos detectados</li> </ol> <pre><code># Carregue o arquivo `media/moedas.jpg` em RGB\nimagem = cv2.cvtColor(cv2.imread(\"media/moedas.jpg\"), cv2.COLOR_BGR2RGB)\n\n# Exiba a imagem\nplt.imshow(imagem, cmap=\"gray\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#passo-1-suavizar-a-imagem","title":"Passo 1: Suavizar a imagem","text":"<p>Vamos converter a imagem para escala de cinza e aplicar filtros de suaviza\u00e7\u00e3o (Blur) para reduzir ru\u00eddos.</p> <pre><code># Converta para escala de cinza\ncinza = cv2.cvtColor(imagem, cv2.COLOR_RGB2GRAY)\n\n# Aplique um filtro de suaviza\u00e7\u00e3o Gaussiano\nsuavizada = cv2.GaussianBlur(cinza, (15, 15), 0)\n\n# Exiba a Imagem\nplt.imshow(suavizada, cmap=\"gray\")\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#passo-2-calcular-o-limiar","title":"Passo 2: Calcular o Limiar","text":"<pre><code># Escolha o limiar\nlimiar = 250\n\n# Aplique Limiariza\u00e7\u00e3o Inversa\nvalor, thresh = cv2.threshold(suavizada, limiar, 255, cv2.THRESH_BINARY_INV)\n\n# Exiba a imagem\nplt.imshow(thresh)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#passo-3-detectar-contornos","title":"Passo 3: Detectar Contornos","text":"<p>A fun\u00e7\u00e3o cv2.findContours() no OpenCV \u00e9 usada para detectar os contornos dos objetos em uma imagem bin\u00e1ria. Os contornos s\u00e3o, essencialmente, curvas que conectam pontos cont\u00ednuos de intensidade similar (como os limites de objetos), sendo muito \u00fatil em tarefas de segmenta\u00e7\u00e3o de objetos, detec\u00e7\u00e3o de formas e an\u00e1lise de bordas.</p> <p>Par\u00e2metros: </p> <ul> <li><code>image</code>: A imagem bin\u00e1ria onde os contornos ser\u00e3o detectados. Geralmente, \u00e9 o resultado de uma limiariza\u00e7\u00e3o (como cv2.threshold()) ou da aplica\u00e7\u00e3o de um detector de bordas (como o Canny).</li> <li><code>mode</code>: Define como os contornos ser\u00e3o recuperados (explicado abaixo).</li> <li><code>method</code>: Define como os pontos dos contornos ser\u00e3o armazenados (explicado abaixo).</li> <li><code>contours</code>: \u00c9 uma lista de contornos detectados, onde cada contorno \u00e9 um array de coordenadas de pontos (x, y).</li> <li><code>hierarchy</code>: Uma matriz que cont\u00e9m informa\u00e7\u00f5es sobre a rela\u00e7\u00e3o entre os contornos (por exemplo, se um contorno est\u00e1 dentro de outro).</li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#modos-de-recuperacao-de-contornos","title":"Modos de Recupera\u00e7\u00e3o de Contornos:","text":"<ul> <li><code>cv2.RETR_EXTERNAL</code>:<ul> <li>Retorna apenas os contornos mais externos. Este modo ignora quaisquer contornos internos, sendo \u00fatil quando voc\u00ea s\u00f3 est\u00e1 interessado no objeto principal.</li> <li>Exemplo: Se voc\u00ea tem moedas dentro de uma caixa, ele detectaria apenas a borda da caixa.</li> </ul> </li> <li><code>cv2.RETR_LIST</code>:<ul> <li>Retorna todos os contornos detectados, sem organizar a hierarquia. N\u00e3o estabelece nenhuma rela\u00e7\u00e3o de aninhamento entre os contornos.</li> </ul> </li> <li><code>cv2.RETR_CCOMP</code>:<ul> <li>Organiza todos os contornos em uma hierarquia de dois n\u00edveis: contornos externos e os contornos dos buracos (objetos internos) detectados.</li> </ul> </li> <li><code>cv2.RETR_TREE</code>:<ul> <li>Recupera todos os contornos e constr\u00f3i uma hierarquia completa, o que significa que ele armazena as rela\u00e7\u00f5es de aninhamento entre os contornos (pai-filho, irm\u00e3o, etc.).</li> </ul> </li> </ul>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#metodos-de-aproximacao-de-contornos","title":"M\u00e9todos de Aproxima\u00e7\u00e3o de Contornos","text":"<ul> <li><code>cv2.CHAIN_APPROX_NONE</code>:<ul> <li>Armazena todos os pontos do contorno, sem compress\u00e3o. Se voc\u00ea quer manter todos os pontos ao longo do contorno, use esta op\u00e7\u00e3o.</li> </ul> </li> <li><code>cv2.CHAIN_APPROX_SIMPLE</code>:<ul> <li>Comprime segmentos horizontais, verticais e diagonais, mantendo apenas os pontos finais desses segmentos. Isso reduz o n\u00famero de pontos necess\u00e1rios para representar o contorno, o que economiza mem\u00f3ria.</li> </ul> </li> </ul> <p>Vamos detectar os contornos usando o modo <code>cv2.RETR_EXTERNAL</code> e o m\u00e9todo <code>cv2.CHAIN_APPROX_SIMPLE</code>.</p> <pre><code># Detecte os contornos\ncontornos, _ = cv2.findContours(\n    image=thresh, mode=cv2.RETR_EXTERNAL, method=cv2.CHAIN_APPROX_SIMPLE\n)\n\n# Verifique quantos contornos foram encontrados\nlen(contornos)\n</code></pre> <p>Agora podemos desenhar os contornos dos objetos detectados:</p> <pre><code># Fa\u00e7a uma c\u00f3pia da imagem para desenhar os contornos\nimagem_contornos = imagem.copy()\n\n# Desenhe os contornos na imagem\ncv2.drawContours(imagem_contornos, contornos, -1, (255, 0, 0), 5)\n\n# Escreva na imagem o n\u00famero de moedas encontradas\ntexto = f\"Contagem de Moedas: {len(contornos)}\"\ncv2.putText(\n    imagem_contornos,\n    texto,\n    (10, 30),\n    cv2.FONT_HERSHEY_SIMPLEX,\n    1,\n    (255, 0, 0),\n    2,\n)\n\n# Exiba a imagem\nplt.imshow(imagem_contornos)\n</code></pre>"},{"location":"Conte%C3%BAdo-do-Workshop/5-Opera%C3%A7%C3%B5es-de-Limiariza%C3%A7%C3%A3o-e-Detec%C3%A7%C3%A3o-de-Contornos/#passo-4-desenhando-caixas-delimitadoras","title":"Passo 4: Desenhando Caixas Delimitadoras","text":"<p>A fun\u00e7\u00e3o cv2.boundingRect(contorno) calcula o ret\u00e2ngulo que encapsula o contorno especificado.</p> <pre><code># Fa\u00e7a uma c\u00f3pia da imagem para desenhar as bounding boxes\nimagem_bbox = imagem.copy()\n\n# Itere sobre os contornos para inser\u00ed-los na imagem\nfor contorno in contornos:\n    (x, y, w, h) = cv2.boundingRect(contorno)\n    cv2.rectangle(imagem_bbox, (x, y), (x + w, y + h), (0, 255, 0), 5)\n\n# Exiba a imagem\nplt.imshow(imagem_bbox)\n</code></pre> <ul> <li>  Continua na pr\u00f3xima se\u00e7\u00e3o: Projeto Final.</li> </ul>"},{"location":"Projeto-Final/Metodologia/","title":"Projeto Final","text":"<ul> <li> Objetivo do Projeto: Elaborar um prot\u00f3tipo de sistema para Detec\u00e7\u00e3o de Movimento em uma c\u00e2mera de seguran\u00e7a.</li> </ul> <ul> <li>Elaborar um script python (<code>scripts/movement.py</code>)</li> <li>O script deve ler o feed de uma webcam</li> <li>Deve aplicar as t\u00e9cnicas necess\u00e1rias para detectar movimentos no v\u00eddeo</li> <li>A sa\u00edda deve apresentar as detec\u00e7\u00f5es dentro de caixas delimitadoras</li> </ul>"},{"location":"Projeto-Final/Metodologia/#metodologia","title":"Metodologia","text":"<p>A metodologia proposta como solu\u00e7\u00e3o para o projeto \u00e9 a seguinte:</p> <p></p> <p>Tente implementar uma solu\u00e7\u00e3o seguindo esta metodologia.</p> <ul> <li> O c\u00f3digo do detector de movimentos j\u00e1 implementado pode ser encontrado na Pr\u00f3xima P\u00e1gina.</li> </ul>"},{"location":"Projeto-Final/Projeto-Final/","title":"Projeto Final","text":"<p> Discuss\u00e3o: Como utilizar uma combina\u00e7\u00e3o das t\u00e9cnicas apresentadas em um \u00fanico projeto?</p> <p></p> <ul> <li> Objetivo do Projeto: Elaborar um prot\u00f3tipo de sistema para Detec\u00e7\u00e3o de Movimento em uma c\u00e2mera de seguran\u00e7a.</li> </ul> <ul> <li>Elaborar um script python (<code>scripts/movement.py</code>)</li> <li>O script deve ler o feed de uma webcam</li> <li>Deve aplicar as t\u00e9cnicas necess\u00e1rias para detectar movimentos no v\u00eddeo</li> <li>A sa\u00edda deve apresentar as detec\u00e7\u00f5es dentro de caixas delimitadoras</li> </ul> <p> Dica: a metodologia \u00e9 composta de seis passos dentre os citados acima.</p> <p></p> <ul> <li> Tente selecionar as seis etapas necess\u00e1rias para implementar o detector de movimentos.</li> </ul> <ul> <li>  A pr\u00f3xima p\u00e1gina apresenta a sequ\u00eancia correta de etapas a serem implementadas.</li> </ul>"},{"location":"Projeto-Final/Solu%C3%A7%C3%A3o/","title":"Projeto Final","text":"<ul> <li> Objetivo do Projeto: Elaborar um prot\u00f3tipo de sistema para Detec\u00e7\u00e3o de Movimento em uma c\u00e2mera de seguran\u00e7a.</li> </ul> <ul> <li>Elaborar um script python (<code>scripts/movement.py</code>)</li> <li>O script deve ler o feed de uma webcam</li> <li>Deve aplicar as t\u00e9cnicas necess\u00e1rias para detectar movimentos no v\u00eddeo</li> <li>A sa\u00edda deve apresentar as detec\u00e7\u00f5es dentro de caixas delimitadoras</li> </ul>"},{"location":"Projeto-Final/Solu%C3%A7%C3%A3o/#metodologia","title":"Metodologia","text":"<p>A metodologia proposta como solu\u00e7\u00e3o para o projeto \u00e9 a seguinte:</p> <p></p>"},{"location":"Projeto-Final/Solu%C3%A7%C3%A3o/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>O c\u00f3digo a seguir implementa as funcionalidades requisitadas:</p> <pre><code># ---------------------------------------------------------------------------- #\n#                                 Projeto Final                                #\n# ---------------------------------------------------------------------------- #\n\n# Objetivo: Implementar uma metodologia de detec\u00e7\u00e3o de movimentos em um feed de video\n# Passo a Passo:\n# 1. Leitura de feed de Webcam\n# 2. Subtrair o frame atual do frame anterior\n# 3. Aplicar filtro de GaussianBlur\n# 4. Aplicar Limiariza\u00e7\u00e3o\n# 5. Encontrar os contornos dos movimentos\n# 6. Desenhar bounding boxes\n\n# Importar as bibliotecas necess\u00e1rias\nimport cv2\n\n# Criar o objeto Capture (Selecionar o id da webcam correta)\ncapture = cv2.VideoCapture(2)\n\n# Ler frames de webcam\nret, frame1 = capture.read()\nret, frame2 = capture.read()\n\nwhile capture.isOpened():\n    # Subtrair o frame atual do frame anterior\n    diff = cv2.absdiff(frame1, frame2)\n\n    # Converter para escala de cinza\n    gray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)\n\n    # Aplicar Gaussian Blur\n    blur = cv2.GaussianBlur(gray, (15, 15), 0)\n\n    # Aplicar Limiariza\u00e7\u00e3o\n    _, thresh = cv2.threshold(blur, 20, 255, cv2.THRESH_BINARY)\n\n    # Encontrar os contornos\n    contornos, _ = cv2.findContours(\n        thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE\n    )\n\n    for contorno in contornos:\n        # Desenhar as caixas delimitadoras\n        (x, y, w, h) = cv2.boundingRect(contorno)\n\n        # Filtrar contornos com \u00e1rea menor que 3000\n        # Ajustar o valor se necess\u00e1rio\n        if cv2.contourArea(contorno) &lt; 3000:\n            continue\n\n        # Desenhar o ret\u00e2ngulo\n        cv2.rectangle(frame1, (x, y), (x + w, y + h), (0, 255, 0), 5)\n\n        # Alerta de Movimento\n        cv2.putText(\n            frame1,\n            \"Movimento Detectado!\",\n            (30, 80),\n            cv2.FONT_HERSHEY_PLAIN,\n            4,\n            (0, 0, 255),\n            4,\n        )\n\n    # Visualizar frame\n    cv2.imshow(\"Frame\", frame1)\n\n    # Pr\u00f3ximo frame\n    frame1 = frame2\n    ret, frame2 = capture.read()\n\n    # Aguardar bot\u00e3o para fechar janelas\n    if cv2.waitKey(40) == ord(\"q\"):\n        break\n\ncv2.destroyAllWindows()\ncapture.release()\n</code></pre>"}]}